---
layout: post
title: "뒤죽박죽 좌충우돌 에디터 커스텀하기"
subtitle: "tiptap 에디터 다루기"
date: 2025-12-12 05:50:05 -0400
background: '/img/posts/06.jpg'
---

# 뒤죽박죽 좌충우돌 에디터 커스텀하기

### 주제: 에디터를 활용한 웹 앱

학습 해야 할 내용!

- contenteditable에 대해
- prosemirror
- tiptap
- WYSIWYG
- Bold, Italic → 어떤 원리로 키 매핑을 통해 css가 적용이 되어 기능하는지

## WYSIWYG

What You See Is What You Get

사용자가 편집 화면에서 보는 모양 그대로 최종 결과물로 나타나는 편집 환경

### 에디터 개발 목표

일단 에디터를 활용하고 그 에디터를 통해 작성한 글을 확인할 수 있게 하고

웹 앱을 배포하는 것까지가 일차적인 목표이다.

동작 원리를 이해하고 그 내용들을 공유하는 것이 그 다음 목표

### contenteditable에 대해

브라우저마다 에디터를 import해서 사용한다고 해도 브라우저 엔진이 firefox, chrome 등 각자 다르기 때문에 표시되는 태그들이 다르다.

실제로 html로 확인했을 때와 react로 확인했을 때도 div와 paragraph(JSON 형태)로 당장 차이를 느낄 수 있었다.

contenteditable에서 커서를 활용하는 방법?

contenteditable은 다 좋은데 개발자가 일일이 다 코딩해서 기능을 개발해 주어야 한다는 단점이 있다.

그래서 온전히 처음부터 내가 다 개발해도 되지만 에디터를 혼자서 개발하지 말라는 선조님?들의 지혜와 tiptap이 어떻게 동작하는지 원리를 파악하면서 공부해도 충분히 도움이 될 것 같아 그렇게 결정하였다.

### Drag & Drop 인터랙션의 원리

**브라우저 이벤트를 가로채어(Intercept) 커스텀 로직 수행**

### **1. 브라우저의 기본 동작 (Default)**

- 브라우저는 파일을 드롭하면 **자동으로 해당 파일을 열어버리는(View)** 성질이 있음.
- **Goal:** 이 기본 동작을 막고(`preventDefault`), 파일 데이터만 추출해야 함.

### **2. 이벤트 객체와 DataTransfer**

- 사용자가 파일을 놓는 순간, OS는 브라우저에게 파일 정보를 전달.
- 이 정보는 **`event.dataTransfer.files`** 라는 배열 객체에 담김.
- **`File` 객체 포함 정보:** 파일명, 크기(Size), 타입(MIME Type), 데이터 참조값.

**~~(오른쪽: 코드 흐름도)~~**

> ~~(PPT에 네모 박스와 화살표로 그려 넣으세요)~~
> 
1. **Drop 감지** 🖱️
    - 사용자가 에디터 영역에 파일 투척
2. **가로채기 (Intercept)** ✋
    - `event.preventDefault()`
    - 브라우저가 이미지를 새 탭으로 여는 것을 차단
3. **데이터 추출 (Extract)** 📦
    - `event.dataTransfer.files[0]` 접근
4. **업로드 함수 실행** 🚀
    - 추출한 File 객체를 `uploadImage()` 함수로 전달

### 이미지 텍스트 변환 원리 - **Base64 인코딩**

Binary 데이터를 텍스트로 변환하여 DB에 직접 저장

### **1. 왜 텍스트로 바꾸는가?**

- **Binary(0/1)** 데이터는 JSON 포맷의 데이터베이스(Firestore)에 직접 저장할 수 없음.
- 별도의 스토리지 서버 없이 **DB에 통합 저장**하기 위해 문자열 변환이 필수.

### **2. 변환 과정 (FileReader API)**

- **Step 1 (Input):** 이미지 파일의 이진 데이터(Binary)를 읽음.
- **Step 2 (Encoding):** 8비트(Byte) 단위를 **6비트 단위**로 재분할.
- **Step 3 (Mapping):** 64개의 문자셋(A-Z, a-z, 0-9, +, /)에 1:1 매칭.

**(오른쪽: 결과 및 특징)**

### **3. Data URL 스킴**

- 변환된 결과물은 브라우저가 해석 가능한 문자열 형태가 됨.
- 예: `data:image/png;base64,iVBORw0KGgo...`

### **4. Trade-off (기술적 고려사항)**

- **장점:** 서버 구현 비용 0원, 관리 포인트 일원화.
- **단점:** 원본 대비 용량이 **약 33% 증가** (6비트 매핑 과정의 오버헤드).
    - *대응:* 800KB 이하의 이미지만 허용하도록 유효성 검사 로직 적용.

### Slash Command 기능 노션처럼 넣어보기

Notion이나 Slack처럼 `/` 키를 눌렀을 때 메뉴를 띄우는 기능으로, 이 기능을 구현하려면 Tiptap의 **`Suggestion`** 유틸리티를 응용해야 합니다. 

원래 멘션(`@`) 기능을 위해 만들어진 건데, 트리거 문자를 `/`로 바꾸면 슬래시 메뉴가 됨.

1. tippy.js와  tiptap의 suggestion 플러그인이 필요함.

```bash
npm install @tiptap/suggestion tippy.js
```

1. 메뉴 UI 컴포넌트 만들기 (`CommandList.js`)
    
    /를 눌렀을 때 뜨는 디자인임. 키보드 위/아래 화살표로 움직이는 로직이 있음.
    
2. 슬래시 명령어 로직 만들기 (`slashCommand.js`)
    
    어떤 메뉴를 보여줄지(`items`), 그리고 선택하면 무슨 동작을 할지 정의함.
    
3. MyEditor.js와 연결하기

### 이런 단축키를 연결하는 기능(/), 키 매핑(ctrl + b) 하는 원리는 어떻게 만든걸까?

그냥 유틸리티에 기능이 있으니까 가져와서 썼다는 그런 단순한 얘기말고 내부 기능적인 부분이 궁금해서 Gemini에게 물어보았음.

결론부터 말하면, 이 기능은 브라우저의 이벤트 루프(Event Loop)를 가로채서(Intercept), 우리가 정의한 '명령어 사전(Keymap)'과 대조한 뒤, **브라우저의 기본 동작을 막고(Prevent Default)** 우리가 만든 함수를 실행하는 "거대한 스위치 분기문"의 집합입니다.

### 1. 로우 레벨: 브라우저 이벤트 가로채기 (Event Listener)

모든 키 매핑의 시작은 `keydown` 이벤트 리스너입니다. Tiptap(ProseMirror)은 에디터 영역(`contenteditable` 요소)에 이벤트 리스너를 딱 하나 걸어둡니다.

가장 기초적인 바닐라 JS 원리는 이렇습니다.

JavaScript

`element.addEventListener('keydown', (event) => {
  // 1. 어떤 키가 눌렸는지 정보(Event Object)를 뜯어봅니다.
  const key = event.key; // 'b'
  const isMod = event.ctrlKey || event.metaKey; // Windows는 Ctrl, Mac은 Cmd

  // 2. 만약 우리가 아는 단축키라면?
  if (isMod && key === 'b') {
    // 3. 브라우저가 원래 하려던 행동(즐겨찾기 목록 열기 등)을 죽입니다.
    event.preventDefault(); 
    
    // 4. 그리고 우리가 만든 'Bold' 함수를 실행합니다.
    executeCommand('toggleBold');
  }
});`

여기까지는 쉽죠? 하지만 에디터는 단축키가 수백 개입니다. 이걸 `if-else`로 다 짤 수 없으니 **디자인 패턴**이 등장합니다.

### **2. 미들웨어 레벨: 키맵(Keymap) 패턴과 정규화**

Tiptap(ProseMirror) 내부에는 **Keymap**이라는 플러그인 시스템이 있습니다. 개발자가 `Mod-B`라고 입력하든, `Control-B`라고 입력하든 알아서 처리해 주는 **'정규화(Normalization)'** 과정이 필요합니다.
**내부 작동 메커니즘**
1. **키 조합 파싱:** `'Mod-Shift-Enter'` 같은 문자열을 받으면, 내부적으로 비트마스크나 객체 형태로 변환해 둡니다.
2. 우선순위 큐(Chain of Responsibility):
단축키는 여러 플러그인에서 동시에 정의될 수 있습니다.
    ◦ 예: `Enter` 키
    ◦ 리스트 플러그인: "리스트 다음 줄 생성"
    ◦ 기본 에디터: "그냥 줄 바꿈"
    ◦ 멘션 창: "멘션 선택"
이때 에디터는 등록된 플러그인들을 **순서대로 훑으면서(Walking through plugins)**, `Enter` 이벤트를 처리하겠다고 손든 녀석(`return true`)이 있으면 거기서 멈춥니다(Stop Propagation).

### **3. 하이 레벨: Slash Command의 원리 (Input Rules & Transaction)**

질문하신 **Slash(`/`) 메뉴**는 `Ctrl+B`와는 조금 다른, 훨씬 고차원적인 기술인 **Input Rules(입력 규칙)** 또는 **Suggestion System**을 사용합니다.
단순히 키를 누르는 게 아니라, **"타이핑된 텍스트의 패턴"**을 감시합니다.

**Slash Command 작동 시퀀스**
1. **타이핑 감지:** 사용자가 `/`를 칩니다.
2. **트랜잭션(Transaction) 분석:**
    ◦ 단순 키 이벤트가 아니라, 에디터의 **상태(State) 변화**를 감시합니다.
    ◦ "방금 입력된 글자가 `/`인가?" + "커서 위치가 문단의 시작인가?" 등을 체크합니다.
3. **가상 DOM 좌표 계산 (핵심 기술):**
    ◦ 메뉴를 띄우려면 `/` 글자가 화면 **어디에(x, y좌표)** 있는지 알아야 합니다.
    ◦ 하지만 `/`는 텍스트일 뿐 HTML 요소가 아닙니다.
    ◦ 내부적으로 **`view.coordsAtPos(커서위치)`** 같은 API를 써서, 텍스트 노드의 정확한 픽셀 좌표를 계산해 냅니다. (이게 기술적으로 제일 까다로운 부분 중 하나입니다.)
4. **포탈(Portal) 렌더링:**
    ◦ 계산된 좌표 옆에 리액트 컴포넌트(메뉴 박스)를 `absolute` 포지션으로 띄웁니다.
**4. 정리: 당신이 `Ctrl+B`를 누를 때 일어나는 일**
프론트엔드 개발자 언어로 최종 정리하면 다음과 같습니다.
1. **Event Capture:** 브라우저가 `keydown` 이벤트를 발생시킴.
2. **Lookup:** ProseMirror의 `keymap` 플러그인이 현재 활성화된 키 맵 객체(`{ 'Mod-b': toggleBold, ... }`)를 순회함.
3. **Match:** `event.ctrlKey`와 `event.key === 'b'`가 매칭되는 항목을 찾음.
4. **Dispatch:** 매칭된 `toggleBold` **커맨드 함수**를 실행.
5. **State Update (불변성):**
    ◦ `toggleBold`는 DOM을 직접 건드리지 않음.
    ◦ "현재 선택 영역(Selection)의 마크(Mark)에 `bold`를 추가해라"라는 **트랜잭션(Transaction)**을 만듦.
6. **Re-render:** 에디터가 새로운 상태(New State)를 받아 Virtual DOM처럼 변경 사항을 비교하고, 실제 DOM에 `<strong>` 태그를 씌움.
즉, "연결해서 다 만든 건지" 물어보셨죠?
네, 맞습니다. 단순히 기능 하나 가져온 게 아니라, **[이벤트 감지 →패턴 매칭 → 상태 변경 → 렌더링]**이라는 거대한 파이프라인을 라이브러리가 미리 연결해 둔 것이고, 우리는 그 파이프라인에 {'Mod-B': 'bold'}라는 **설정값(Config)**만 주입한 것입니다.