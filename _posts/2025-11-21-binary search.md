---
layout: post
title: "Binary Search"
subtitle: "이분 탐색 정복하기"
date: 2025-11-21 14:54:32 -0400
background: '/img/posts/06.jpg'
---

# 이분 탐색 정복하기

두꺼운 전화번호부에서 특정 사람의 이름을 찾는다고 상상해 보자. 첫 페이지부터 한 장씩 넘기며 찾나, 아니면 책의 중간을 펴보고 이름 순서에 따라 앞이나 뒤로 뭉텅이로 넘겨가며 찾는가. 만약 후자를 선택했다면 당신은 이미 이분 탐색의 핵심 원리를 이해하고 있는 것이다. 오늘은 데이터 검색의 속도를 획기적으로 줄여주는 이분 탐색에 대해 알아보겠다.

## 이분 탐색이란 무엇인가?

이분 탐색은 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 찾는 알고리즘이다. 가장 직관적인 예시는 술자리에서 흔히 하는 Up/Down 게임이다. 1부터 100 사이의 숫자 중 사회자가 생각한 숫자(예: 73)를 맞혀야 할 때, 1부터 순서대로 부르는 사람은 없다. 보통 50을 외치고 Up이라는 힌트를 받으면 1부터 50까지의 수는 버리고 51부터 100 사이에서 다시 중간값을 찾는 방식을 사용한다. 이처럼 범위를 절반씩 뚝뚝 잘라내기 때문에 데이터가 아무리 많아도 매우 빠르게 원하는 값을 찾아낼 수 있는 것이다.

## 핵심 전제 조건-데이터의 정렬

이분 탐색을 사용하기 위해서 반드시 지켜야 할 절대적인 규칙이 하나 있다. 바로 탐색하려는 데이터가 반드시 정렬(Sorted)되어 있어야 한다는 점이다. 데이터가 크기 순서대로 나열되어 있지 않고 뒤죽박죽 섞여 있다면, 중간값이 찾고자 하는 값보다 큰지 작은지를 기준으로 왼쪽이나 오른쪽을 버리는 전략 자체가 불가능해진다. 따라서 이분 탐색을 적용하려면 데이터 정렬이 선행되어야 한다.

## 동작 원리 시각화

이분 탐색은 시작점(start), 끝점(end), 중간점(mid) 세 가지 변수를 사용하여 범위를 조절하며 동작한다.

먼저 start와 end의 중간 위치인 mid를 구한다. 그 후 mid에 위치한 값과 찾고자 하는 타겟 값을 비교한다. 만약 mid 값이 타겟과 일치한다면 탐색은 성공적으로 종료된다. 반면 타겟 값이 mid 값보다 작다면 찾는 데이터는 왼쪽에 있다는 뜻이므로 end를 mid 바로 앞(mid - 1)으로 옮겨 탐색 범위를 왼쪽 절반으로 줄인다. 반대로 타겟 값이 mid 값보다 크다면 start를 mid 바로 뒤(mid + 1)로 옮겨 오른쪽 절반만 탐색하게 된다. 이 과정을 값을 찾거나 start가 end보다 커질 때까지 반복한다.

## 압도적인 성능을 보일 때.

데이터의 양이 많아질수록 이분 탐색의 진가가 드러난다. 처음부터 끝까지 하나씩 확인하는 순차 탐색(Linear Search)은 데이터가 100만 개라면 최악의 경우 100만 번을 확인해야 하며 시간 복잡도는 O(n)이다.

하지만 이분 탐색(Binary Search)은 시간 복잡도가 O(log n)이다. 이는 데이터가 100만 개라도 약 20번의 비교만으로 원하는 값을 찾을 수 있음을 의미한다. 데이터가 2배로 늘어나도 비교 횟수는 고작 1회 늘어날 뿐이다. 대용량 데이터를 처리하는 환경에서 이분 탐색이 필수적인 이유가 바로 여기에 있다.

## Python 코드 구현

이분 탐색은 재귀 함수보다 반복문(While Loop)을 사용하는 것이 일반적이며 함수 호출에 따른 오버헤드를 줄일 수 있어 효율적이다. 아래는 반복문을 이용한 표준적인 구현 코드이다.

```python
def binary_search(array, target, start, end):
    while start <= end:
        mid = (start + end) // 2
        
        # 찾는 값을 발견한 경우 인덱스 반환
        if array[mid] == target:
            return mid
            
        # 찾는 값이 중간점보다 작은 경우 왼쪽 확인 (end 포인트 이동)
        elif array[mid] > target:
            end = mid - 1
            
        # 찾는 값이 중간점보다 큰 경우 오른쪽 확인 (start 포인트 이동)
        else:
            start = mid + 1
            
    return None # 값을 찾지 못한 경우

# 사용 예시
arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
target = 7
result = binary_search(arr, target, 0, len(arr) - 1)

print(f"타겟 위치: {result}")
```

또한 파이썬은 `bisect`라는 강력한 내장 라이브러리를 제공한다. 코딩 테스트와 같은 실전 환경에서는 직접 구현하기보다 검증된 라이브러리를 사용하는 것이 훨씬 유리하다.

```python
from bisect import bisect_left, bisect_right

arr = [1, 2, 4, 4, 8]
# 정렬된 순서를 유지하면서 4를 삽입할 가장 왼쪽 인덱스 반환
print(bisect_left(arr, 4)) # 결과: 2
```

## 주의해야 할 점

알고리즘을 구현할 때 몇 가지 주의할 점이 있다. 
첫째, 앞서 강조했듯 정렬되지 않은 배열에 적용하면 잘못된 결과가 나오므로 반드시 정렬 상태를 확인해야 한다. 
둘째, while 문 내부에서 start와 end 값을 업데이트할 때 `mid + 1` 혹은 `mid - 1` 처리를 명확히 하지 않으면 무한 루프에 빠질 수 있다. 
셋째, 파이썬이 아닌 C++나 Java 같은 언어에서는 `(start + end)` 계산 과정에서 int 자료형의 범위를 넘어서는 오버플로우가 발생할 수 있으므로 `start + (end - start) // 2`와 같은 방식으로 중간값을 구하는 것이 안전하다.

## 마치며

이분 탐색은 단순해 보이지만 대규모 데이터 처리에서 성능을 결정짓는 중요한 알고리즘이다. "탐색 범위가 매우 크다"라는 조건이 문제에 주어진다면 가장 먼저 이분 탐색을 떠올려 보길 바란다. 정렬된 데이터와 절반씩 줄어드는 탐색 범위, 이 두 가지만 기억한다면 효율적인 코드를 작성할 수 있다.